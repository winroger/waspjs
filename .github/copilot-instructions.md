# Copilot Project Guide

- **Monorepo layout**: Core library lives in [packages/waspjs](packages/waspjs); Vite demo app in [apps/demo](apps/demo) uses static assets from [public/examples](public/examples) and config in [apps/demo/src/config/availableSets.ts](apps/demo/src/config/availableSets.ts). Placeholder READMEs mark future package/app moves.
- **Build & run**: From repo root use `npm run dev` for the demo, `npm run build` for lib+demo, `npm run test` / `npm run test:watch` (Vitest scoped to [packages/waspjs/tests](packages/waspjs/tests)), and `npm run lint` for eslint over src/tests. Library build uses tsup config in [packages/waspjs/tsup.config.js](packages/waspjs/tsup.config.js).
- **Entry points**: Package exports are wired in [packages/waspjs/src/index.js](packages/waspjs/src/index.js) (Aggregation, Part, Rule, Connection, Plane, Collider, Visualizer, utilities, importers, and data types).
- **Core data model**: Parts aggregate via rules into an `Aggregation` ([packages/waspjs/src/core/aggregation.js](packages/waspjs/src/core/aggregation.js)). `Part` holds geometry, connections, collider, parent/child links, and keeps active connections reset per rule set ([packages/waspjs/src/core/part.js](packages/waspjs/src/core/part.js)). `Connection` stores a plane and type and builds its rules table from the provided rules ([packages/waspjs/src/core/connection.js](packages/waspjs/src/core/connection.js)). Rules are simple pairs of part/connection ids ([packages/waspjs/src/core/rule.js](packages/waspjs/src/core/rule.js)).
- **Geometry & transforms**: Planes retain orthonormal axes with `applyMatrix4onPlane` helpers ([packages/waspjs/src/core/plane.js](packages/waspjs/src/core/plane.js)). Mesh serialization uses `meshToData`/`meshFromData` and matrix helpers `transformToData`/`transformFromData` ([packages/waspjs/src/core/utilities.js](packages/waspjs/src/core/utilities.js)); tests round-trip these conversions in [packages/waspjs/tests/serialization.test.js](packages/waspjs/tests/serialization.test.js).
- **Rule generation**: When rule files are absent, `generateRules` synthesizes rules across all part connections, optionally type-aware and skipping self-links ([packages/waspjs/src/core/utilities.js](packages/waspjs/src/core/utilities.js)); covered by [packages/waspjs/tests/utilities.test.js](packages/waspjs/tests/utilities.test.js). Use `buildAggregationFromPartsAndRules` to load serialized parts and rules (auto-generates when missing) and `buildAggregationFromJson`/`fromData` for direct aggregation payloads ([packages/waspjs/src/importers](packages/waspjs/src/importers)).
- **Aggregation logic**: `Aggregation.aggregate_rnd` grows assemblies by randomly selecting active connections and rules, transforming candidate parts via `newPlaneToPlane`, and skipping placements that collide (BVH-based check) before finalizing parent/child bookkeeping ([packages/waspjs/src/core/aggregation.js](packages/waspjs/src/core/aggregation.js)). `modifyParts` keeps the Three.js scene in sync when parts are added/removed. Randomness is seeded via `rnd_seed` using a Mulberry32 RNG.
- **Collision handling**: `Collider` supports single or per-connection colliders and can filter valid connections when `multiple` meshes are provided ([packages/waspjs/src/core/collider.js](packages/waspjs/src/core/collider.js)). Mesh intersection uses `three-mesh-bvh` accelerated raycast; make sure meshes have geometry and call `updateMatrixWorld` before checks.
- **Rendering**: `Visualizer` wraps Three.js + camera-controls, enforces Z-up (`camera.up.set(0,0,1)`), and mounts into DOM selectors passed to the constructor ([packages/waspjs/src/core/visualizer.js](packages/waspjs/src/core/visualizer.js)). Uses transparent background and fixed light rig; resizing relies on parent container dimensions.
- **Demo assets & tests**: Demo config lists `availableSets` pointing at aggregation JSON in public examples; tests assert these files exist/parse ([packages/waspjs/tests/demoExamples.test.js](packages/waspjs/tests/demoExamples.test.js)). Keep config paths and public assets aligned when adding demos to avoid breaking tests.
- **Conventions & gotchas**: ESM across repo; threejs types used directly (no TypeScript declarations generated). Colors for loaded parts use the color map in import/build helpers. Aggregation deserialization currently throws for `global_constraints` and `catalog` placeholders—avoid relying on these fields until implemented.

Questions or missing pieces? Tell me which areas need more detail (build, demo wiring, data formats, or aggregation behavior) and I’ll refine this guide.